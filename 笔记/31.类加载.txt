
ClassLoader 类加载器

类加载器(ClassLoader)用来加载 Java类 到 Java虚拟机(JVM) 中。

Java源程序(*.java)经过Java编译器后被转换成Java字节码(*.class)，类加载器负责读取Java字节码，并转换
成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个Java类。通过此实例的 newInstance()方法
就可以创建出该类的一个对象。

类加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创
建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类加载的最终产品是位于堆区中的Class对象，
Class对象封装了类在方法区内的数据结构，并且向程序员提供了访问方法区内的数据结构的接口。

JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失
或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)。如果这个类一直没有被
程序主动使用，那么类加载器就不会报告错误。

加载.class文件的方式
1)从本地系统中直接加载
2)通过网络下载.class文件
3)从zip，jar等归档文件中加载.class文件
4)从专有数据库中提取.class文件
5)将Java源文件动态编译为.class文件

---------------------------------------------------------------------------------------------------------
类加载器分为:
1.引导类加载器(启动类加载器，Bootstrap ClassLoader)
它用来加载 Java 的核心库。是用原生代码来实现的，并不继承自 java.lang.ClassLoader。
启动类加载器是无法被Java程序直接引用的。

2.扩展类加载器(Extension ClassLoader)
它用来加载 Java 的扩展库。Java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载 Java 类。
该加载器由 sun.misc.Launcher$ExtClassLoader 实现。

3.应用程序类加载器(Application ClassLoader)
它根据 Java 应用的类路径(classpath)来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。
可以通过 ClassLoader.getSystemClassLoader() 来获取它。该类加载器由 sun.misc.Launcher$AppClassLoader 实现。

除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，
以满足一些特殊的需求。

---------------------------------------------------------------------------------------------------------
JVM类加载机制
1.全盘负责
当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用
另外一个类加载器来载入。

2.父类委托
先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。

3.缓存机制
缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，
只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。
(注: 这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。)

---------------------------------------------------------------------------------------------------------
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括:
加载(Loading)、
验证(Verification)、
准备(Preparation)、
解析(Resolution)、
初始化(Initialization)、
使用(Using)、
卸载(Unloading)
7个阶段。

其中准备、验证、解析3个部分统称为连接(Linking)。

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而解析
阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或
晚期绑定)。

1.加载(查找并加载类的二进制数据)
在加载阶段(可以参考java.lang.ClassLoader的loadClass()方法)，虚拟机需要完成以下3件事情:
1)通过一个类的全限定名来获取定义此类的二进制字节流(并没有指明要从一个Class文件中获取，可以从其他渠道，譬如:
  网络、动态生成、数据库等);
2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;
3)在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段和连接阶段(Linking)的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶
段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定
的先后顺序。

2.验证(确保被加载的类的正确性)
验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机
自身的安全。

验证阶段大致会完成4个阶段的检验动作:
1)文件格式验证: 验证字节流是否符合Class文件格式的规范; 例如: 是否以魔术0xCAFEBABE开头、主次版本号是否在当前
  虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
2)元数据验证: 对字节码描述的信息进行语义分析(注意:对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语
  言规范的要求; 例如: 这个类是否有父类，除了java.lang.Object之外。
3)字节码验证: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
4)符号引用验证: 确保解析动作能正确执行。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑
采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

3.准备(为类的静态变量分配内存，并将其初始化为默认值)
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进
行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在
堆中。

例如:
public static int value=123;

变量value在准备阶段过后的初始值为0而不是123。因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic
指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。
至于"特殊情况"是指: public static final int value=123，即当类字段的字段属性是ConstantValue时，会在准备阶
段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0。

4.解析(把类中的符号引用转换为直接引用)
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法
类型、方法句柄和调用点限定符7类符号引用进行。

5.初始化(为类的静态变量赋予正确的初始值)
类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经
赋过一次系统要求的初始值，而在初始化阶段，则通过程序制定的主管计划去初始化类变量和其他资源，或者说: 初始化阶段
是执行类构造器<clinit>()方法的过程。

---------------------------------------------------------------------------------------------------------
类加载有三种方式:
1.命令行启动应用时候由JVM初始化加载
2.通过Class.forName()方法动态加载
3.通过ClassLoader.loadClass()方法动态加载

Class.forName()和ClassLoader.loadClass()区别:
Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块;
ClassLoader.loadClass(): 将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。
(注: Class.forName(name, initialize, loader) 带参函数也可控制是否加载static块。)

---------------------------------------------------------------------------------------------------------
双亲委派模型

双亲委派模型的工作流程是: 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托
给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它
的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

双亲委派机制:
1.当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2.当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3.如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载。
4.若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

ClassLoader源码:

public Class<?> loadClass(String name)throws ClassNotFoundException {
    return loadClass(name, false);
}

protected synchronized Class<?> loadClass(String name, boolean resolve)throws ClassNotFoundException {
  // 首先判断该类型是否已经被加载
  Class c = findLoadedClass(name);

  if (c == null) {
  	//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
  	try {
  	    if (parent != null) {
  		 //如果存在父类加载器，就委派给父类加载器加载
  		c = parent.loadClass(name, false);
  	    } else {
  	        //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
  		c = findBootstrapClass0(name);
  	    }
  	} catch (ClassNotFoundException e) {
  	    // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
  	    c = findClass(name);
  	}
  }

  if (resolve) {
	  resolveClass(c);
  }

  return c;
}

双亲委派模型意义:
1.系统类防止内存中出现多份同样的字节码
2.保证Java程序安全稳定运行

---------------------------------------------------------------------------------------------------------
Object和Class两个类之间的区别:
Object是所有类的父类，所有类当然也包括Class类。所以，Object类是Class类的父类。
Class这个类的构造方法是私有的，所以不能显式的new一个Class对象。它是用来描述一个对象的元信息的。
